{"posts":[{"content":" 题意： 给出k类硬币和每类硬币的数量和正面朝上的概率，问每类硬币成为幸运硬币的概率是多少。成为幸运硬币的条件是每投一次将所有背面朝上的硬币去掉，继续抛掷，直至剩下一种或者一个都不剩下，那最后一种留下的硬币就是幸运硬币。 分析： 这题公式推导比较新颖。 一般的划分状态在此题因为状态过多开销巨大而不适用，所以考虑以每次投掷硬币为依据划分阶段。 设 die[i][j]die[i][j]die[i][j] 表示第 iii 类硬币在第 jjj 次投掷（包括第 jjj 次）前就已经被抛弃的概率； 易得：die[i][j]=(1−p[i]j)num[i]die[i][j] = (1 - p[i]^j)^{num[i]}die[i][j]=(1−p[i]j)num[i] 方便起见，再定一个 alive[i][j]alive[i][j]alive[i][j]，表示第 iii 类硬币在第 jjj 次投掷（包括第 jjj 次）后至少有一个硬币还存在的概率； 显然：alive[i][j]=1−die[i][j]alive[i][j] = 1 - die[i][j]alive[i][j]=1−die[i][j] 第 iii 类硬币在第 kkk 轮投掷后成为幸运硬币的概率就是： alive[i][k]×( ∏j=1,j≠indie[j][k]−∏j=1,j≠indie[j][k−1] )alive[i][k] \\times (\\ \\prod_{j=1,j \\neq i }^{n}{die[j][k] } - \\prod_{j=1,j \\neq i }^{n}{die[j][k - 1] }\\ )alive[i][k]×( ∏j=1,j​=in​die[j][k]−∏j=1,j​=in​die[j][k−1] ) 其中 ( ∏j=1,j≠indie[j][k]−∏j=1,j≠indie[j][k−1] )(\\ \\prod_{j=1,j \\neq i }^{n}{die[j][k] } - \\prod_{j=1,j \\neq i }^{n}{die[j][k - 1] }\\ )( ∏j=1,j​=in​die[j][k]−∏j=1,j​=in​die[j][k−1] ) 表示的是其他硬币在第 k−1k-1k−1 轮还至少存在一个，到了第 kkk 轮全部被抛弃的概率。 因此第 iii 类硬币成为幸运硬币的概率就是： ∑k=1∞alive[i][k]×( ∏j=1,j≠indie[j][k]−∏j=1,j≠indie[j][k−1] )\\sum_{k=1}^{∞} alive[i][k] \\times (\\ \\prod_{j=1,j \\neq i }^{n}{die[j][k] } - \\prod_{j=1,j \\neq i }^{n}{die[j][k - 1] }\\ )∑k=1∞​alive[i][k]×( ∏j=1,j​=in​die[j][k]−∏j=1,j​=in​die[j][k−1] ) 这里需要注意特判一下 n=1n = 1n=1（nnn 种硬币） 时即只有 111 类硬币的情况。 值得推敲的就是求和公式的 ∞∞∞ 符号，真的要取到很大很大，大到无穷项吗？ 其实是不需要的，每次投掷硬币有 0.4~0.6 的概率是正面向上，那么当进行几十轮后，这个硬币仍然向上的概率是很小，所以这个求和式很快就收敛了。 因此最终答案就是： ans[i]=∑k=1100alive[i][k]×( ∏j=1,j≠indie[j][k]−∏j=1,j≠indie[j][k−1] )ans[i] = \\sum_{k=1}^{100} alive[i][k] \\times (\\ \\prod_{j=1,j \\neq i }^{n}{die[j][k] } - \\prod_{j=1,j \\neq i }^{n}{die[j][k - 1] }\\ )ans[i]=∑k=1100​alive[i][k]×( ∏j=1,j​=in​die[j][k]−∏j=1,j​=in​die[j][k−1] ) 其实看很多大佬的博客最后答案写的是： 这个式子表示第 stepstepstep 步时,其他硬币在 111 到 stepstepstep 步内死光了,只剩下 iii 硬币存活,继续扔, iii 硬币在 step+1step+1step+1 步时死光了。我个人觉得是比较难以理解其中的含义。但是实际上我之前写的式子经过变形后也可以得到这个式子，各位读者可以自行选择理解。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 15, M = 105; double p[N], alive[N][M], die[N][M]; int num[N]; double qmi(double a, int b) { double ans = 1; for (; b; b &gt;&gt;= 1) { if (b &amp; 1) ans = ans * a; a = a * a; } return ans; } int main() { int t; scanf(&quot;%d&quot;, &amp;t); while (t--) { int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d%lf&quot;, &amp;num[i], &amp;p[i]); if (n == 1) puts(&quot;1.000000&quot;); else { for (int i = 1; i &lt;= n; i++) // 预处理die, alive { double P = 1; for (int j = 0; j &lt;= 100; j++) { die[i][j] = qmi(1 - P, num[i]); alive[i][j] = 1 - die[i][j]; P *= p[i]; } } for (int i = 1; i &lt;= n; i++) { double ans = 0; for (int k = 1; k &lt;= 100; k++) { double x = 1, y = 1; for (int j = 1; j &lt;= n; j++) { if (j == i) continue; x *= die[j][k]; y *= die[j][k - 1]; } ans += alive[i][k] * (x - y); } printf(&quot;%.6f&quot;, ans); if (i == n) printf(&quot;\\n&quot;); else printf(&quot; &quot;); } } } return 0; } ","tags":[{"name":"ACM","slug":"0jbTa4vmH","used":true,"link":"https://liuyl.site/tag/0jbTa4vmH/"}],"title":"ICPC2016青岛 D - Lucky Coins","link":"https://liuyl.site/post/icpc2016-qingdao-lucky-coins/","stats":{"text":"6 min read","time":313000,"words":1080,"minutes":6},"dateFormat":"2022-11-24"}]}
